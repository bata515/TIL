## 認証と認可の違い
- 認証
  - 利用者が誰であるかを確認するプロセス

- 認可
  - 認証された利用者がどのリソースにアクセスできるかを決定するプロセス

## JWTとは
- JSON Web Tokenの略
- JWTとは、情報を安全にやり取りするための国際的なルール（RFC 7519）として標準化された仕様の一つ
  - RFC 7519: JWTの仕様を定義した文書で、JSON Web Tokenの構造や使用方法を規定しています。
  https://tex2e.github.io/rfc-translater/html/rfc7519.html

### JWTの例）
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
- JWTは、3つの部分から構成されている。
  1. ヘッダー（Header）: トークンの種別（typ）と、署名アルゴリズム（alg）を定義するパートです。
  2. ペイロード（Payload）: ユーザーIDや権限、有効期限など、伝達したい情報（クレーム）を含むパートです。
  3. 署名（Signature）: ヘッダーとペイロードが改ざんされていないことを保証するためのデジタル署名です。
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
{
  "iss": "example.com",
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
{
  "signature": "HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)"
}
```

### JWTの利点
- **自己完結性**: JWTは必要な情報をすべて含むため、サーバー側でセッション情報を保持する必要がない。
- **スケーラビリティ**: サーバー側で認証状態を管理しないため、リクエストをどのサーバーで処理してもよく、スケーラビリティを確保しやすくなります。(セッションIDだとサーバーで認証情報を管理していたので、サーバーのスケーリングがしづらかった。。)
- **改ざん耐性**: デジタル署名によって、トークンの内容が途中で書き換えられていないかを検証できます。

### 署名について
署名は以下の手順で生成されます。

> HMACSHA256( Base64URL(ヘッダー) + "." + Base64URL(ペイロード), 秘密鍵 )

つまり、「エンコードされたヘッダー」と「エンコードされたペイロード」を.で連結した文字列を、ヘッダーで指定されたアルゴリズムと、サーバーだけが知っている秘密鍵を使って計算したハッシュ値です。

この秘密鍵を知らない第三者は、たとえヘッダーやペイロードを改ざんしても、正しい署名を再生成することができません。サーバーはリクエストを受け取るたびに、同じ方法でリクエストのヘッダー+ペイロード+サーバーが持つ秘密鍵で署名を計算し直し、送られてきた署名と一致するかを検証することで、トークンの正当性を確認します。

### JWTでの認証認可のイメージ
![alt text](image.png)

### 実際のプロダクトでの利用
- 実際のプロダクトでは、IDaaS (Identity as a Service)を利用して、認証と認可を行うことが一般的です。
  - IDaaSは、ユーザーの認証情報を安全に管理し、JWTなどのトークンを生成して認証認可の仕組みを提供するものです。
  - これにより、開発者はセキュリティの実装に集中でき、ユーザー認証の複雑さを軽減できます。
  - 代表的なIDaaSには、Auth0、Firebase Authentication、Amazon Cognitoなどがあります
  - これらのサービスは、ユーザーの登録、ログイン、SSO（シングルサインオン）、多要素認証などの機能を提供し、JWTを利用してセッション管理を行うこともできます。

